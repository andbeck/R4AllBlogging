---
title: "Working with your dinosauR"
author: "APB"
date: "13/03/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
'We will one day all be dinosauRs'

## Working with Your dinosauR, who learned base R, and not the tidyverse.

We are acutely aware that in moving our teaching material to the tidyverse, and particularly to ggplot2 and dplyr for graphing and data manipulation, we have created as situation where students may be learning how to do things differently than their supervisors, fellow students, post-docs and people/help groups they interact with online for help.  We are acutely aware, because it's happened around us, with our own students.  This isn't bad.  It is fun.  Really.

The good news is that the statistics have not changed, what we teach about statistics in the book has not really changed for decades, or even eons.  

But getting to the point where you do the statistics - e.g. organising your data and making a good figure before you start analysing the data - well, this has changed.  More specifically, there are now more ways to do this than before. This blog post is designed to highlight what's changed and why we think this new way is good.  But it is also designed to help you in 'working with dinosauRs'.

### Messing with your data: dplyr vs. base
In our book, we provide a table with comparative code from dplyr and base R.  Here we expand a bit on this, providing a New R User template for speaking and interacting with your pet dinosauR.

![OldNew](old_new_comparison_table.pdf)

#### dplyr review
dplyr is a toolbox with a set of functions optimised to do one thing and one thing very well and very fast. It is also designed to help you by first declaring the data frame name (dataset) in which all of your variables are stored, and then asking for things to happen.  This is a unique and standardised toolbox, in this context.

Lets work with three examples that we will connect to base functions in the next section.  Lets get setup with the packages and the data:

```{r}
# libraries you need
library(dplyr)
library(ggplot2)

# we assume you have downloaded the dataset from Getting Started with R
# LINK:

# get the data into R using read.csv().
compensation <- read.csv('compensation.csv')

# glimpse it.
glimpse(compensation)
```

##### SELECT a column
With dplyr, we can select a column with one function and in one way:

```{r}
# use select().  The first argument is the data frame and the second is the column.
select(compensation, Fruit)
```

The important detail here is that dplyr functions alway take the data frame as the first argument and ALWAYS return a data frame object.

How can you do this in base R?  What might you see from the dinosauRs?  Well, lots of different ways to do the 'same' thing.... almost.  Lets look at 3 ways, and see what happens.

```{r}
# Base Method 1: $
compensation$Fruit

# Base Method2: [ ]
compensation[,'Fruit']
# OR
compensation[,2]

# Base Method 3: subset()
subset(compensation, select = Fruit)
```

What do we notice?  Well, not only are there 4 ways to do the same thing, only one of them actually returns 'exactly' what dplyr's select() does, a data frame of Fruit.  Which one?  `subset()`.

What are the other three returning?  They are returning vectors... e.g. just the numbers. They are not organised into a single column data frame with a column lable called Fruit.  This might be what you want sometimes... it might not other times.  Keep in mind that this, we believe, is one of the fun bits of R.

#### Select a Row or Rows.
Selecting rows in R is also as variable as selecting columns.

Lets recall the dplyr method - `slice()`

```{r}
slice(compensation, 2) # get the second row
```

Notice that again, dplyr function `slice()` starts with the data frame as it's first argument, and then specifies the row number.  And importantly, we now have a 1 row, 3 column data frame.

Base R provides one way to do this.

```{r}
# Base Method 1: [ ]
compensation[2,]
```

Note that the outcome is  the same (it's got the right numbers) AND it has returned a data frame.  Interesting.... eh?

#### Subset or Filter by a Variable
The final bit of base-dplyr punch up we want to compare involves subsetting your data.  Lets imaging we want to return all rows that have Fruit values > 80 kg.  Lets work through several ways to do this with base R, and then shift to dplyr.

```{r}
# Base Method 1: [ ]
compensation[compensation$Fruit>80,]

#Base Method 2: subset()
subset(compensation, subset = Fruit > 80)
```

OK.  Good news.  Both produce the same output, and both return a data frame.  

Lets recall how dplyr does this using `filter()`

```{r}
filter(compensation, Fruit > 80)
```

Notice the similarities between `subset()` and `filter()`.  However, lets try and make this a bit more complicated to see how different Base methods stack up to dplyr tools.  Lets now not only request Fruit > 80, but also JUST return the Root values where Fruit > 80.

```{r}
# Base Method 1: [ ]
compensation[compensation$Fruit>80,]$Root

#Base Method 2: subset()
subset(compensation, subset = Fruit > 80, select = Root)
```

Notice two things here.  First, Base Method 1 involves `[ ]` and `$`.  It also now returns a vector, not a data frame.  Second, Base Method 2, using `subset()`, returns a data frame and reveals that the function `subset()` has two arguments that are indeed quite handy: susbet = and select =.  Very nice indeed.

What do we need to do to replicate the functionality of subset() in dplyr?  Actually, there are two ways to do this: we call them the nested method and the piping method.

```{r}
select(filter(compensation, Fruit>80), Root) # nested method

compensation %>% filter(Fruit>80) %>% select(Root) # piping method
```




### Messing with your graphs: ggplot2 vs. base (vs. lattice)
